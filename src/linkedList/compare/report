В ходе сравнения разных вариантов коллекций можно придти к следующим выводам:

1)ArrayList и LinkedList.

Во многих источниках сказано : "при добавлении или удалении  в (из) середину(ы) коллекции множества элементов,
 то  лучше использовать LinkedList. Во всех остальных случаях – ArrayList.". Данный вывод логичен, но в моем случае результаты
 противоречили данному высказыванию. В моем сравнении все операции(вставка в середину, добавление, удаление) ArrayList выполнил быстрее,
 чем LinkedList.

Полученные результаты c количеством элементов в коллекции = 100000 :
Добавление элемента
ArrayList faster , time work = 17950
Удаление элемента
ArrayList faster , time work = 33721
Вставка элемента в середину
ArrayList faster , time work = 40560

2)HashSet, LinkedHashSet, TreeSet

Если говорить о сравнении HashSet, LinkedHashSet, TreeSet для тех же операций, то вывод получается следующий.
Задачу добавления элемента с близкой точностью выполняют HashSet и LinkedListSet , очевидно что TreeSet уступает в скорости,
иак как имеет встроенную сортировку значений.

Говоря о удалении элемента и о проверки наличия элемента(брался элемент из середины),  можно назвать
LinkedHashSet побидетелем по скорости выполнения задачи.

Полученные результаты c количеством элементов в коллекции = 100000 :
Добавление элемента
LinkedHashSet faster , time work = 88567
Удаление последнего элемента
LinkedHashSet faster , time work = 42513
Проерка на содержание элемента в коллекции
LinkedHashSet faster , time work = 46820


3)HashMap, LinkedHashMap, TreeMap

В ходе сравнения реализаций  HashMap, LinkedHashMap, TreeMap- по полученым результатам можно сказать, что
при необходимости добавления элемента лучше использовать HashMap он показал наименьшее время работы по сравнению
с противниками.
При выполнении задачи удаления и проверки на содержания ключа самое быстрое время показывает реализация LinkedHashMap.

Полученные результаты c количеством элементов в коллекции = 100000 :
Добавление элемента
HashMap faster , time work = 54225
Удаление последнего элемента
LinkedHashMap faster , time work = 36405
Проверка на содержание ключа в середине
LinkedHashMap faster , time work = 33741

Вывод: выбор реализации сторого зависит от поставленной задачи.